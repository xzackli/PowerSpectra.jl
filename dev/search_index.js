var documenterSearchIndex = {"docs":
[{"location":"module_index/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"module_index/","page":"Index","title":"Index","text":"","category":"page"},{"location":"module_index/","page":"Index","title":"Index","text":"Modules = [AngularPowerSpectra]","category":"page"},{"location":"module_index/#AngularPowerSpectra.CovarianceWorkspace-Union{Tuple{T}, NTuple{4, CovField{T}}} where T","page":"Index","title":"AngularPowerSpectra.CovarianceWorkspace","text":"CovarianceWorkspace(m_i, m_j, m_p, m_q; lmax::Int=0)\n\nInputs and cache for covariance calculations. A covariance matrix relates the masks of four fields and spins. This structure caches various cross-spectra between masks and noise-weighted masks.\n\nArguments:\n\nm_i::CovField{T}: map i\nm_j::CovField{T}: map j\nm_p::CovField{T}: map p\nm_q::CovField{T}: map q\n\nKeywords\n\nlmax::Int=0: maximum multipole to compute covariance matrix\n\n\n\n\n\n","category":"method"},{"location":"module_index/#AngularPowerSpectra.channelindex-Tuple{Any}","page":"Index","title":"AngularPowerSpectra.channelindex","text":"channelindex(s)\n\nConvert string/char T,E,B => 1,2,3\n\nExamples\n\njulia> channelindex(\"E\")\n2\n\n\n\n\n\n","category":"method"},{"location":"module_index/#AngularPowerSpectra.decouple_covmat-Union{Tuple{SA}, Tuple{T}, Tuple{SA, SA, SA}} where {T, SA<:(OffsetArrays.OffsetArray{T, 2, AA} where AA<:AbstractArray)}","page":"Index","title":"AngularPowerSpectra.decouple_covmat","text":"decouple_covmat(Y, B1, B2; lmin1=2, lmin2=2)\n\nDecouples a covariance matrix Y, performing B‚ÇÅ‚Åª¬π √ó M √ó (B‚ÇÇ‚Åª¬π)^‚Ä† by mutating M. Zeros out ‚Ñì‚ÇÅ, ‚Ñì‚ÇÇ within BOTH lmin1 and lmin2 (i.e the corner).\n\n\n\n\n\n","category":"method"},{"location":"module_index/#AngularPowerSpectra.k·µ§-Tuple{Type, Any}","page":"Index","title":"AngularPowerSpectra.k·µ§","text":"k·µ§([T=Float64], u)\n\nDefined only for u ‚àà {-2, 0, 2}.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#AngularPowerSpectra.map2cl-Union{Tuple{T}, Tuple{Healpix.Map{T, O, AA} where {O<:Healpix.Order, AA<:AbstractVector{T}}, Healpix.Map{T, O, AA} where {O<:Healpix.Order, AA<:AbstractVector{T}}, LinearAlgebra.Factorization, OffsetArrays.OffsetArray{T, 1, AA} where AA<:AbstractArray, OffsetArrays.OffsetArray{T, 1, AA} where AA<:AbstractArray}} where T","page":"Index","title":"AngularPowerSpectra.map2cl","text":"map2cl(...)\n\nArguments:\n\nmap_1::Map{T}: masked map\nmap_2::Map{T}: masked map\nfactorized_mcm::Factorization: lu(mode coupling matrix)\nB‚Ñì_1::SpectralVector{T}: beam associated with first map\nB‚Ñì_2::SpectralVector{T}: beam associated with second map\n\nReturns:\n\nArray{T,1}: spectrum\n\n\n\n\n\n","category":"method"},{"location":"module_index/#AngularPowerSpectra.mask!-Union{Tuple{T}, Tuple{Healpix.Map{T, O, AA} where {O<:Healpix.Order, AA<:AbstractVector{T}}, Healpix.Map{T, O, AA} where {O<:Healpix.Order, AA<:AbstractVector{T}}}} where T","page":"Index","title":"AngularPowerSpectra.mask!","text":"mask!\n\nConvenience function for applying a mask to a map.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#AngularPowerSpectra.mcm-Union{Tuple{T}, Tuple{SpectralWorkspace{T}, String, String, String}} where T","page":"Index","title":"AngularPowerSpectra.mcm","text":"mcm(workspace::SpectralWorkspace{T}, spec::Symbol, f1_name::String, f2_name::String) where {T}\n\nArguments:\n\nworkspace::SpectralWorkspace{T}: stores the SHTs of the masks\nspec::String: the spectrum to compute, such as \"TT\", \"TE\", or \"EE\"\nf1_name::String: the name of the first field\nf2_name::String: the name of the second field\n\nReturns:\n\nSpectralArray{T,2}: zero-indexed array containing the mode-coupling matrix\n\nExamples\n\nm1 = CovField(\"field1\", mask1_T, mask1_P)\nm2 = CovField(\"field2\", mask2_T, mask2_P)\nworkspace = SpectralWorkspace(m1, m2)\nùêå = mcm(workspace, spec, \"field1\", \"field2\")\n\n\n\n\n\n","category":"method"},{"location":"module_index/#AngularPowerSpectra.quickpolW-Union{Tuple{T}, Tuple{Healpix.Alm{Complex{T}, AA} where AA<:AbstractArray{Complex{T}, 1}, Healpix.Alm{Complex{T}, AA} where AA<:AbstractArray{Complex{T}, 1}}} where T<:Number","page":"Index","title":"AngularPowerSpectra.quickpolW","text":"quickpolW(alm‚ÇÅ::Alm{Complex{T}}, alm‚ÇÇ::Alm{Complex{T}})\n\nComputes a scaled spectrum of the scan pattern.\n\nW_ell^nu_1nu_2s_1s_2j_1j_2 = sum_m^prime=-ell^prime^ell^prime\n    left(_s_1+nu_1tildeomega^(j_1)_ell^prime m^primeright)\n    left(_s_2+nu_2tildeomega^(j_2)_ell^prime m^primeright)^*\n\n\n\n\n\n","category":"method"},{"location":"module_index/#AngularPowerSpectra.quickpolŒû!-Union{Tuple{AA}, Tuple{T}, Tuple{AA, Any, Any, Any, Any, Healpix.Alm, Healpix.Alm, Array{Vector{T}, 1}, Array{Vector{T}, 1}}} where {T, AA<:(OffsetArrays.OffsetArray{T, 2, AA} where AA<:AbstractArray)}","page":"Index","title":"AngularPowerSpectra.quickpolŒû!","text":"quickpolŒû!(ùöµ::AA, ŒΩ‚ÇÅ, ŒΩ‚ÇÇ, s‚ÇÅ, s‚ÇÇ, œâ‚ÇÅ, œâ‚ÇÇ)\n\nThis computes the Xi_ell^prime primeell matrix. It assumes rho has been absorbed into the omega terms.\n\nœâ‚ÇÅ: effective scan weights with spin s‚ÇÅ + ŒΩ‚ÇÅ\nœâ‚ÇÇ: effective scan weights with spin s‚ÇÇ + ŒΩ‚ÇÇ\n\n\n\n\n\n","category":"method"},{"location":"module_index/#AngularPowerSpectra.synalm!-Union{Tuple{T}, Tuple{Random.AbstractRNG, AbstractArray{T, 3}, Vector{T} where T}} where T","page":"Index","title":"AngularPowerSpectra.synalm!","text":"synalm!([rng=GLOBAL_RNG], Cl::AbstractArray{T,3}, alms::Vector{Alm{Complex{T}}}) where T\n\nIn-place synthesis of spherical harmonic coefficients, given spectra.\n\nArguments:\n\nCl::AbstractArray{T,3}: array with dimensions of comp, comp, ‚Ñì\nalms::Vector: array of Alm to fill\n\nExamples\n\nnside = 16\nC0 = [3.  2.;  2.  5.]\nCl = repeat(C0, 1, 1, 3nside)  # spectra constant with ‚Ñì\nalms = [Alm{Complex{Float64}}(3nside-1, 3nside-1) for i in 1:2]\nsynalm!(Cl, alms)\n\n\n\n\n\n","category":"method"},{"location":"module_index/#AngularPowerSpectra.synalm-Union{Tuple{T}, Tuple{Random.AbstractRNG, AbstractArray{T, 3}, Int64}} where T","page":"Index","title":"AngularPowerSpectra.synalm","text":"synalm([rng=GLOBAL_RNG], Cl::AbstractArray{T,3}, nside::Int) where T\n\nArguments:\n\nCl::AbstractArray{T,3}: array with dimensions of comp, comp, ‚Ñì\nnside::Int: healpix resolution\n\nReturns:\n\nVector{Alm{T}}: spherical harmonics realizations for each component\n\nExamples\n\nnside = 16\nC0 = [3.  2.;  2.  5.]\nCl = repeat(C0, 1, 1, 3nside)  # spectra constant with ‚Ñì\nalms = synalm(Cl, nside)\n\n\n\n\n\n","category":"method"},{"location":"module_index/#AngularPowerSpectra.Œûsum-Union{Tuple{T}, Tuple{OffsetArrays.OffsetArray{T, 1, AA} where AA<:AbstractArray, WignerFamilies.WignerSymbolVector{T, Int64, AA} where AA<:AbstractVector{T}, WignerFamilies.WignerSymbolVector{T, Int64, AA} where AA<:AbstractVector{T}}} where T<:Number","page":"Index","title":"AngularPowerSpectra.Œûsum","text":"Œûsum(alm‚ÇÅ, alm‚ÇÇ, w3j‚ÇÅ, w3j‚ÇÇ)\n\nSum over ell and m of two a_ell m and nontrivial Wigner-3j vectors. This is a step in computing the mathbfXi matrix. The rho factors are not in this summation, as they can be pulled out.\n\nbeginaligned\n(Xi mathrmsum) = sum_ell^prime m^prime   W_ell^nu_1nu_2s_1s_2j_1j_2 times beginpmatrix ell  ell^prime  ell^primeprime \n     -s_1  s_1+nu_1   -nu_1 endpmatrix beginpmatrix\n     ell  ell^prime  ell^primeprime  -s_2  s_2+nu_2   -nu_2 endpmatrix\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"CurrentModule = AngularPowerSpectra","category":"page"},{"location":"spectra/#Spectral-Analysis","page":"Spectra","title":"Spectral Analysis","text":"","category":"section"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"In this section, we describe how one can estimate unbiased cross-spectra from masked maps using this package. ","category":"page"},{"location":"spectra/#Mode-Coupling-Matrices","page":"Spectra","title":"Mode-Coupling Matrices","text":"","category":"section"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"If you compute the cross-spectrum of masked maps, the mask will couple together different modes. This biased estimate of the true spectrum is termed the pseudo-spectrum widetildeC_ell, ","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"widetildeC_ell = frac12ell+1 sum_m mathsfm^iX_ell m mathsfm^jY_ell m","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"where mathsfm^iX_ell m are the spherical harmonic coefficients of the masked map i of channel X in T E. In the pseudo-C_ell estimator, one seeks an estimate hatC_ell of the true spectrum that is related to the pseudo-spectrum by a linear operator,","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"   widetildeC_ell = mathbfM^XY(ij)_ell_1 ell_2 hatC_ell","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"where mathbfM^XY(ij)_ell_1 ell_2 is the mode-coupling matrix between fields i and j for spectrum XY in TT TE EE. Applying the inverse of the mode-coupling matrix to the pseudo-spectrum widetildeC_ell yields an unbiased and nearly optimal estimate hatC_ell of the true spectrum. To compute the mode-coupling matrix, one needs","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"XY in TT TE EE, the desired spectrum\nmathsfm^iX_ell m, spherical harmonic coefficients of the mask for map i, mode X\nmathsfm^jY_ell m, spherical harmonic coefficients of the mask for map j, mode Y","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"A basic functionality of this package is to compute this matrix. Let's look at a basic example of the cross-spectrum between two intensity maps.","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"# get some example masks\nusing Healpix, AngularPowerSpectra\nmask1 = readMapFromFITS(\"test/data/mask1_T.fits\", 1, Float64)\nmask2 = readMapFromFITS(\"test/data/mask2_T.fits\", 1, Float64)\n\n# compute TT mode-coupling matrix from mask harmonic coefficients\nM = mcm(:TT, map2alm(mask1), map2alm(mask2))","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"Similarly, one could have specified the symbol :TE, :ET, or :EE for other types of cross-spectra[1]. The function mcm returns a SpectralArray{T,2}, which is just a simple array wrapper that makes the array 0-indexed. That means M[‚Ñì‚ÇÅ, ‚Ñì‚ÇÇ] corresponds to the mode-coupling matrix entry mathbfM_ell_1 ell_2. If you want to access the underlying array, you can use mcm.parent. One can optionally truncate the computation with the lmax keyword, i.e. mcm(:TT, mask1, mask2; lmax=10). ","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"[1]: You can combine symbols, in cases where you're looping over combinations of spectra, by using Symbol.julia> Symbol(:T, :T)\n:TT","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"Now one can apply a linear solve to decouple the mask.","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"# generate two uniform maps\nnside = mask1.resolution.nside\nnpix = nside2npix(nside)\nmap1 = Map{Float64, RingOrder}(ones(npix))\nmap2 = Map{Float64, RingOrder}(ones(npix))\n\n# mask the maps with different masks\nmap1.pixels .*= mask1.pixels\nmap2.pixels .*= mask2.pixels\n\n# compute the pseudo-spectrum, and wrap it in a SpectralVector\nalm1, alm2 = map2alm(map1), map2alm(map2)\npCl = SpectralVector(alm2cl(alm1, alm2))\n\n# decouple the spectrum\nCl = M \\ pCl","category":"page"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"Note that this performs the linear solve starting at mathbfell = 2, setting hatC_ell  2 = 0. The linear solve operator on SpectralArrays is specialized to do this. Most of the time you want to avoid the monopole and dipole, which tend to be very large relative to anisotropies. You should subtract the monopole and dipole from your maps. If you really want to perform the linear solve on the monopole and dipole, you can use the underlying arrays to decouple the spectrum, i.e. Cl_starting_from_zero = M.parent \\ pCl.parent. ","category":"page"},{"location":"spectra/#API","page":"Spectra","title":"API","text":"","category":"section"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"mcm","category":"page"},{"location":"spectra/#AngularPowerSpectra.mcm","page":"Spectra","title":"AngularPowerSpectra.mcm","text":"mcm(workspace::SpectralWorkspace{T}, spec::Symbol, f1_name::String, f2_name::String) where {T}\n\nArguments:\n\nworkspace::SpectralWorkspace{T}: stores the SHTs of the masks\nspec::String: the spectrum to compute, such as \"TT\", \"TE\", or \"EE\"\nf1_name::String: the name of the first field\nf2_name::String: the name of the second field\n\nReturns:\n\nSpectralArray{T,2}: zero-indexed array containing the mode-coupling matrix\n\nExamples\n\nm1 = CovField(\"field1\", mask1_T, mask1_P)\nm2 = CovField(\"field2\", mask2_T, mask2_P)\nworkspace = SpectralWorkspace(m1, m2)\nùêå = mcm(workspace, spec, \"field1\", \"field2\")\n\n\n\n\n\n","category":"function"},{"location":"covariance/","page":"Covariance","title":"Covariance","text":"CurrentModule = AngularPowerSpectra","category":"page"},{"location":"covariance/#Covariance-Estimation","page":"Covariance","title":"Covariance Estimation","text":"","category":"section"},{"location":"covariance/","page":"Covariance","title":"Covariance","text":"The covariance between two spectra textrmCov(hatC_ell^XYij hatC_ell^WZpq) for channels XYWZ in T E obtained from masked maps can be expressed using","category":"page"},{"location":"covariance/","page":"Covariance","title":"Covariance","text":"spherical harmonic coefficients of the masks of the four maps i j p q involved in the covariance\nassumed signal spectrum C_ellmathrmtot^XY, for example C_ell^mathrmth + C_ell^mathrmfgij\npixel variance maps sigma_p^XX for XX in II QQ UU for the four maps involved in the covariance","category":"page"},{"location":"covariance/","page":"Covariance","title":"Covariance","text":"However, these are only sufficient for a description of a homogeneous survey with white noise and sufficient mask apodization. Two additional corrections are required for sim1 covariance determinations.","category":"page"},{"location":"covariance/","page":"Covariance","title":"Covariance","text":"noise power spectra hatN_ell^XYij for the involved channels\ncorrections to the diagonals of the covariance matrices from insufficient apodization around point sources","category":"page"},{"location":"covariance/","page":"Covariance","title":"Covariance","text":"The basic calculation is essentially a mode-coupling calculation, and mode-coupling matrices are themselves used to correct the covariance matrix at the end. The methods in this package were written to match the analysis of the Planck satellite, and we provide a more detailed description of these methods in Li et al. 2020 (in prep). The derivation of these covariance matrices, in the limit of uniform noise, are available in Thibaut Louis's excellent notes.","category":"page"},{"location":"covariance/","page":"Covariance","title":"Covariance","text":"The mode-coupling matrix is essentially a linear operator on the cross-spectrum of the masks. In contrast, the expressions for the covariance matrix tend to reuse the same expressions many times, and one tends also to compute several different covariance matrices (i.e. TTTT, TETE, TTTE) on the same maps. The covariance calculation in AngularPowerSpectra.jl is centered around the CovarianceWorkspace, which caches the various quantities that are re-used during covariance estimation.","category":"page"},{"location":"covariance/#Computing-the-Covariance","page":"Covariance","title":"Computing the Covariance","text":"","category":"section"},{"location":"covariance/","page":"Covariance","title":"Covariance","text":"First, let's set up the required data ‚Äì masks and variances. The variance is a Healpix.PolarizedMap containing the fields i, q, u. In this example, we read the masks from disk, but set the variances for everything to 1.","category":"page"},{"location":"covariance/","page":"Covariance","title":"Covariance","text":"using Healpix, AngularPowerSpectra\nmask1_T = readMapFromFITS(\"test/data/mask1_T.fits\", 1, Float64)\nmask2_T = readMapFromFITS(\"test/data/mask2_T.fits\", 1, Float64)\nmask1_P = readMapFromFITS(\"test/data/mask1_T.fits\", 1, Float64)\nmask2_P = readMapFromFITS(\"test/data/mask2_T.fits\", 1, Float64)\n\n# for this example, pixel variance = 1\nunit_var = PolarizedMap{Float64, RingOrder}(nside)\nunit_var.i .= 1.0\nunit_var.q .= 1.0\nunit_var.u .= 1.0","category":"page"},{"location":"covariance/","page":"Covariance","title":"Covariance","text":"Once you have the masks and variances, you can create a CovField for each field involved. This structure also has an associated name, which is used for the signal spectra.","category":"page"},{"location":"covariance/","page":"Covariance","title":"Covariance","text":"# set up CovField, we're computing the variance of a spectrum on (f1 √ó f2)\nf1 = CovField(\"143_hm1\", mask1_T, mask1_P, unit_var)\nf2 = CovField(\"143_hm2\", mask2_T, mask2_P, unit_var)\nf3 = f1\nf4 = f2\n\n# compute covariance between the (f1 √ó f2) spectrum and (f3 √ó f4) spectrum  \nw = CovarianceWorkspace(f1, f2, f3, f4)","category":"page"},{"location":"covariance/","page":"Covariance","title":"Covariance","text":"A covariance matrix calculation needs an assumed signal spectrum for each channel you want.  You need to generate a dictionary that maps the names of various cross-spectra to SpectralVector.","category":"page"},{"location":"covariance/","page":"Covariance","title":"Covariance","text":"nside = mask1.resolution.nside\ncl_th = SpectralVector(ones(nside2lmax(nside)))\n\nspectra = Dict{SpectrumName, SpectralVector{Float64, Vector{Float64}}}(\n    (:TT, \"143_hm1\", \"143_hm1\") => cl_th, (:TT, \"143_hm1\", \"143_hm2\") => cl_th,\n    (:TT, \"143_hm2\", \"143_hm1\") => cl_th, (:TT, \"143_hm2\", \"143_hm2\") => cl_th,\n\n    (:EE, \"143_hm1\", \"143_hm1\") => cl_th, (:EE, \"143_hm1\", \"143_hm2\") => cl_th,\n    (:EE, \"143_hm2\", \"143_hm1\") => cl_th, (:EE, \"143_hm2\", \"143_hm2\") => cl_th ,\n\n    (:TE, \"143_hm1\", \"143_hm1\") => cl_th, (:TE, \"143_hm1\", \"143_hm2\") => cl_th,\n    (:TE, \"143_hm2\", \"143_hm1\") => cl_th, (:TE, \"143_hm2\", \"143_hm2\") => cl_th)","category":"page"},{"location":"covariance/","page":"Covariance","title":"Covariance","text":"Now all that remains is to compute the coupled covmat.","category":"page"},{"location":"covariance/","page":"Covariance","title":"Covariance","text":"C = coupled_covmat(:TT, :TT, \"143_hm1\", \"143_hm2\", w, spectra)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = AngularPowerSpectra","category":"page"},{"location":"#AngularPowerSpectra","page":"Home","title":"AngularPowerSpectra","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AngularPowerSpectra.jl is a package for power spectrum analysis on the sphere. It computes mode-coupling matrices and covariance matrices for TT, TE, and EE spectra, using pseudo-C_ell methods (i.e. Hivon et al. 2002, Efstathiou 2006, Hamimeche and Lewis 2008). It can also compute  beam matrices in the QuickPol formalism (Hivon et al. 2017).","category":"page"},{"location":"#Conventions:-SpectralArray-and-SpectralVector","page":"Home","title":"Conventions: SpectralArray and SpectralVector","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package wraps outputs in a custom SpectralArray, which is a simple array type that just makes the array 0-indexed. This is very useful for manipulating angular spectra, as multipoles start with the monopole ell = 0. The type SpectralVector is an alias for a one-dimensional array, SpectralArray{T,1}. The one major difference is that matrix multiplication and linear solve operator \\ are specialized for SpectralArray to ignore the monopole and dipole, as pseudo-C_ell methods do not handle those multipoles very well.","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can wrap an array A without copying by just calling SpectralArray(A).","category":"page"},{"location":"beams/","page":"Beams","title":"Beams","text":"CurrentModule = AngularPowerSpectra","category":"page"},{"location":"beams/#QuickPol","page":"Beams","title":"QuickPol","text":"","category":"section"},{"location":"beams/","page":"Beams","title":"Beams","text":"We provide utilities to compute beam matrices in the QuickPol formalism (Hivon et al. 2017). We introduce some additional steps here for computational efficiency. In this section, we use the indices ell ell ell such that we don't need to change indices at the end in order to match Hivon. Define a scaled version of the scan spectrum","category":"page"},{"location":"beams/","page":"Beams","title":"Beams","text":"W_ell^nu_1nu_2s_1s_2j_1j_2 = sum_m^prime=-ell^prime^ell^prime  left(_s_1+nu_1tildeomega^(j_1)_ell^prime m^primeright)\n    left(_s_2+nu_2tildeomega^(j_2)_ell^prime m^primeright)^*","category":"page"},{"location":"beams/","page":"Beams","title":"Beams","text":"Define the matrix,","category":"page"},{"location":"beams/","page":"Beams","title":"Beams","text":"beginaligned\nmathbfXi^nu_1nu_2s_1s_2j_1j_2_ell^primeprimeell = (-1)^s_1 + s_2 + nu_1 + nu_2 sum_ell^prime  rho_j_1nu_1 rho_j_2 nu_2  W_ell^nu_1nu_2s_1s_2j_1j_2  \n qquadqquad times beginpmatrix ell  ell^prime  ell^primeprime \n     -s_1  s_1+nu_1   -nu_1 endpmatrix beginpmatrix\n     ell  ell^prime  ell^primeprime  -s_2  s_2+nu_2   -nu_2 endpmatrix\nendaligned","category":"page"},{"location":"beams/","page":"Beams","title":"Beams","text":"This matrix does not depend on u_1 u_2. We can then write the beam matrix in terms of mathbfXi,","category":"page"},{"location":"beams/","page":"Beams","title":"Beams","text":"mathbfB_ell^primeprimeell^nu_1nu_2 u_1 u_2 = sum_j_1 j_2 s_1 s_2 frac2ell + 14pi _u_1hatb^(j_1)*_ell s_1 _u_2hatb^(j_2)*_ell s_2  frack_u_1 k_u_2k_nu_1 k_nu_2  mathbfXi^nu_1nu_2s_1s_2j_1j_2_ell^primeprimeell","category":"page"},{"location":"beams/","page":"Beams","title":"Beams","text":"With this definition, the beam matrices mathbfB are sub-blocks of the linear operator relating the cross-spectrum to the beamed cross-spectrum (Hivon+17 eq. 38),","category":"page"},{"location":"beams/","page":"Beams","title":"Beams","text":"tildeC^nu_1nu_2_ell^primeprime = sum_u_1u_2left(sum_ell mathbfB_ell^primeprimeell^nu_1nu_2 u_1 u_2 C_ell^u_1 u_2 right)","category":"page"},{"location":"beams/","page":"Beams","title":"Beams","text":"Note that the inner sum is just a matrix-vector multiplication.","category":"page"},{"location":"beams/","page":"Beams","title":"Beams","text":"quickpolŒû!\nquickpolW\nk·µ§","category":"page"},{"location":"beams/#AngularPowerSpectra.quickpolŒû!","page":"Beams","title":"AngularPowerSpectra.quickpolŒû!","text":"quickpolŒû!(ùöµ::AA, ŒΩ‚ÇÅ, ŒΩ‚ÇÇ, s‚ÇÅ, s‚ÇÇ, œâ‚ÇÅ, œâ‚ÇÇ)\n\nThis computes the Xi_ell^prime primeell matrix. It assumes rho has been absorbed into the omega terms.\n\nœâ‚ÇÅ: effective scan weights with spin s‚ÇÅ + ŒΩ‚ÇÅ\nœâ‚ÇÇ: effective scan weights with spin s‚ÇÇ + ŒΩ‚ÇÇ\n\n\n\n\n\n","category":"function"},{"location":"beams/#AngularPowerSpectra.quickpolW","page":"Beams","title":"AngularPowerSpectra.quickpolW","text":"quickpolW(alm‚ÇÅ::Alm{Complex{T}}, alm‚ÇÇ::Alm{Complex{T}})\n\nComputes a scaled spectrum of the scan pattern.\n\nW_ell^nu_1nu_2s_1s_2j_1j_2 = sum_m^prime=-ell^prime^ell^prime\n    left(_s_1+nu_1tildeomega^(j_1)_ell^prime m^primeright)\n    left(_s_2+nu_2tildeomega^(j_2)_ell^prime m^primeright)^*\n\n\n\n\n\n","category":"function"},{"location":"beams/#AngularPowerSpectra.k·µ§","page":"Beams","title":"AngularPowerSpectra.k·µ§","text":"k·µ§([T=Float64], u)\n\nDefined only for u ‚àà {-2, 0, 2}.\n\n\n\n\n\n","category":"function"}]
}
